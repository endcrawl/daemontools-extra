#!/usr/bin/env python
'''
Like unixserver(1), but just listen and exec the subordinate program
with the listening socket as stdin. The subordinate program still needs
to call accept(2) on stdin.
'''

import sys
import os
import os.path
import socket
import errno

prog = sys.argv.pop(0)
usage = "usage: %s [-b backlog] [-m octal-mode] socket-path program" % prog
mode = 0770
backlog = 128

while len(sys.argv):
  arg0 = sys.argv[0]
  if arg0 == '-m':
    sys.argv.pop(0)
    mode = int(sys.argv.pop(0),8)
  elif arg0 == '-b':
    sys.argv.pop(0)
    backlog = int(sys.argv.pop(0))
  elif arg0 == '--':
    sys.argv.pop(0)
    break
  elif arg0.startswith('-'):
    print >> sys.stderr, usage
    exit(1)
  else:
    break

if len(sys.argv) < 2:
  print >> sys.stderr, usage
  exit(1)

path = os.path.realpath(sys.argv.pop(0))

# Remove socket from previous run, if it exists.
try:
  os.unlink(path)
except OSError, e:
  if e.errno != errno.ENOENT:
    raise

s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.bind(path)
os.chmod(path, mode)
s.listen(backlog)
os.dup2(s.fileno(),0)
os.close(s.fileno())
os.execvp(sys.argv[0],sys.argv)

